<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Web-LLM-API æµ‹è¯•å°</title>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; font-family: sans-serif; display: flex; height: 100vh; }
        
        /* ä¾§è¾¹æ æ ·å¼ */
        .sidebar { width: 250px; background: #f5f5f5; border-right: 1px solid #ddd; display: flex; flex-direction: column; }
        .sidebar-header { padding: 15px; border-bottom: 1px solid #ddd; }
        .sidebar-header h3 { margin: 0; font-size: 16px; }
        .conversation-list { flex: 1; overflow-y: auto; padding: 10px; }
        .conversation-item { padding: 10px; margin-bottom: 5px; background: white; border-radius: 5px; cursor: pointer; border: 1px solid #ddd; transition: all 0.2s; }
        .conversation-item:hover { background: #e3f2fd; border-color: #007bff; }
        .conversation-item.active { background: #007bff; color: white; border-color: #007bff; }
        .conversation-item-title { font-weight: bold; margin-bottom: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; cursor: pointer; padding: 2px 4px; border-radius: 3px; }
        .conversation-item-title:hover { background: rgba(0,0,0,0.05); }
        .conversation-item.active .conversation-item-title:hover { background: rgba(255,255,255,0.2); }
        .conversation-item-title-input { width: 100%; padding: 4px; border: 1px solid #007bff; border-radius: 3px; font-size: 14px; font-weight: bold; }
        .conversation-item-time { font-size: 12px; opacity: 0.7; }
        .conversation-item-actions { margin-top: 5px; display: flex; gap: 5px; }
        .conversation-item-actions button { padding: 3px 8px; font-size: 12px; background: #dc3545; border: none; border-radius: 3px; color: white; cursor: pointer; }
        .conversation-item-actions button:hover { background: #c82333; }
        .conversation-item.active .conversation-item-actions button { background: rgba(255,255,255,0.3); }
        .conversation-item.active .conversation-item-actions button:hover { background: rgba(255,255,255,0.5); }
        
        /* ä¸»å†…å®¹åŒºæ ·å¼ */
        .main-content { flex: 1; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; padding: 20px; width: 100%; }
        #chat-box { flex: 1; border: 1px solid #ddd; overflow-y: scroll; padding: 10px; margin-bottom: 10px; border-radius: 8px; background: #f9f9f9; min-height: 0; }
        .message { margin-bottom: 15px; padding: 10px; border-radius: 5px; }
        .user { background-color: #e3f2fd; text-align: right; }
        .ai { background-color: #fff; border: 1px solid #eee; }
        .config-area { display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
        .config-area select { padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        .input-area { display: flex; gap: 10px; }
        input { flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 4px; }
        button { padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:disabled { background: #ccc; }
        .new-chat-btn { background: #28a745; }
        .new-chat-btn:hover { background: #218838; }
    </style>
</head>
<body>
<!-- ä¾§è¾¹æ ï¼šå¯¹è¯åˆ—è¡¨ -->
<div class="sidebar">
    <div class="sidebar-header">
        <h3>ğŸ’¬ å¯¹è¯åˆ—è¡¨</h3>
        <button onclick="createNewConversation()" class="new-chat-btn" style="width: 100%; margin-top: 10px; padding: 8px;">+ æ–°å¯¹è¯</button>
    </div>
    <div class="conversation-list" id="conversationList">
        <!-- å¯¹è¯åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
    </div>
</div>

<!-- ä¸»å†…å®¹åŒº -->
<div class="main-content">
<h2>ğŸ¤– Web-LLM-API è°ƒè¯•å™¨</h2>
<div class="config-area">
    <select id="providerSelect" onchange="onProviderChange()">
        <option value="">åŠ è½½ä¸­...</option>
    </select>
    <select id="modelSelect">
        <option value="">åŠ è½½ä¸­...</option>
    </select>
    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
        <input type="checkbox" id="thinkingToggle" style="width: auto; cursor: pointer;">
        <span>æ·±åº¦æ€è€ƒ</span>
    </label>
</div>
<div id="chat-box"></div>
<div class="input-area">
    <button onclick="newChat()" class="new-chat-btn" id="newChatBtn">æ–°å¯¹è¯</button>
    <input type="text" id="prompt" placeholder="è¾“å…¥é—®é¢˜æµ‹è¯•ï¼Œä¾‹å¦‚ï¼šè®²ä¸ªç¬‘è¯..." onkeypress="if(event.keyCode==13) send()">
    <button onclick="send()" id="sendBtn">å‘é€</button>
</div>

<!-- ä½¿ç”¨ ES6 æ¨¡å—æ–¹å¼å¼•å…¥ OpenAI SDK -->
<script type="module">
    // åŠ¨æ€å¯¼å…¥ OpenAI SDK
    const { default: OpenAI } = await import('https://cdn.jsdelivr.net/npm/openai@6.10.0/+esm');
    
    const chatBox = document.getElementById('chat-box');
    const providerSelect = document.getElementById('providerSelect');
    const modelSelect = document.getElementById('modelSelect');
    
    let providersData = {};
    let modelsData = [];
    let conversationHistory = []; // ç»´æŠ¤å½“å‰å¯¹è¯å†å²
    let currentConversationId = null; // å½“å‰å¯¹è¯ID
    const STORAGE_KEY = 'web_llm_conversations'; // localStorage é”®å

    // åˆå§‹åŒ– OpenAI å®¢æˆ·ç«¯ï¼ˆæŒ‡å‘æœ¬åœ°åç«¯ï¼‰
    // åˆ›å»ºè‡ªå®šä¹‰ fetch å‡½æ•°æ¥æ·»åŠ è‡ªå®šä¹‰ header
        const customFetch = async (url, options = {}) => {
        // ä»å…¨å±€å˜é‡è·å– newConversation å€¼
        const newConv = window._currentNewConversation !== undefined 
            ? String(window._currentNewConversation) 
            : 'false';
        
        // è·å–æ·±åº¦æ€è€ƒæ¨¡å¼çŠ¶æ€
        const thinkingToggle = document.getElementById('thinkingToggle');
        const thinking = thinkingToggle ? thinkingToggle.checked : false;
        
        // è·å–å½“å‰å¯¹è¯çš„ URLï¼ˆå¦‚æœæœ‰ï¼‰
        const conversations = loadConversations();
        const currentConv = currentConversationId ? conversations[currentConversationId] : null;
        const conversationUrl = currentConv?.url || '';
        
        // æ­£ç¡®å¤„ç† headersï¼ˆå¯èƒ½æ˜¯ Headers å¯¹è±¡ã€æ™®é€šå¯¹è±¡æˆ– undefinedï¼‰
        let headers;
        if (options.headers instanceof Headers) {
            headers = new Headers(options.headers);
            headers.set('X-New-Conversation', newConv);
            headers.set('X-Thinking', String(thinking));
            if (conversationUrl) {
                headers.set('X-Conversation-URL', conversationUrl);
            }
        } else if (options.headers) {
            // å¦‚æœæ˜¯æ™®é€šå¯¹è±¡ï¼Œè½¬æ¢ä¸º Headers
            headers = new Headers(options.headers);
            headers.set('X-New-Conversation', newConv);
            headers.set('X-Thinking', String(thinking));
            if (conversationUrl) {
                headers.set('X-Conversation-URL', conversationUrl);
            }
        } else {
            headers = new Headers();
            headers.set('X-New-Conversation', newConv);
            headers.set('X-Thinking', String(thinking));
            if (conversationUrl) {
                headers.set('X-Conversation-URL', conversationUrl);
            }
        }
        
        // å¦‚æœæ˜¯ POST è¯·æ±‚ï¼Œä¹Ÿéœ€è¦åœ¨ body ä¸­æ·»åŠ  thinking å‚æ•°
        if (options.method === 'POST' && options.body) {
            try {
                const body = JSON.parse(options.body);
                body.thinking = thinking;
                options.body = JSON.stringify(body);
            } catch (e) {
                // å¦‚æœè§£æå¤±è´¥ï¼Œå¿½ç•¥
            }
        }
        
        return fetch(url, {
            ...options,
            headers: headers
        });
    };
    
    const openai = new OpenAI({
        baseURL: 'http://localhost:24753/v1',
        apiKey: 'not-needed', // æœ¬åœ°åç«¯ä¸éœ€è¦çœŸå®çš„ API Key
        dangerouslyAllowBrowser: true, // å…è®¸åœ¨æµè§ˆå™¨ä¸­ä½¿ç”¨
        fetch: customFetch // ä½¿ç”¨è‡ªå®šä¹‰ fetch
    });
    
    // ä» localStorage åŠ è½½å¯¹è¯åˆ—è¡¨
    function loadConversations() {
        try {
            const data = localStorage.getItem(STORAGE_KEY);
            return data ? JSON.parse(data) : {};
        } catch (e) {
            console.error('åŠ è½½å¯¹è¯åˆ—è¡¨å¤±è´¥:', e);
            return {};
        }
    }
    
    // ä¿å­˜å¯¹è¯åˆ—è¡¨åˆ° localStorage
    function saveConversations(conversations) {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
        } catch (e) {
            console.error('ä¿å­˜å¯¹è¯åˆ—è¡¨å¤±è´¥:', e);
        }
    }
    
    // ç”Ÿæˆå¯¹è¯ID
    function generateConversationId() {
        return 'conv_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    // æ¸²æŸ“å¯¹è¯åˆ—è¡¨
    function renderConversationList() {
        const conversations = loadConversations();
        const listDiv = document.getElementById('conversationList');
        listDiv.innerHTML = '';
        
        // æŒ‰æ—¶é—´å€’åºæ’åˆ—
        const sortedConvs = Object.entries(conversations).sort((a, b) => 
            b[1].updatedAt - a[1].updatedAt
        );
        
        sortedConvs.forEach(([id, conv]) => {
            const item = document.createElement('div');
            item.className = 'conversation-item' + (id === currentConversationId ? ' active' : '');
            item.onclick = () => loadConversation(id);
            
            const title = conv.title || 'æ–°å¯¹è¯';
            const time = new Date(conv.updatedAt).toLocaleString('zh-CN', {
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            item.innerHTML = `
                <div class="conversation-item-title" onclick="editConversationTitle('${id}', event)" title="ç‚¹å‡»ç¼–è¾‘æ ‡é¢˜">${escapeHtml(title)}</div>
                <div class="conversation-item-time">${time}</div>
                <div class="conversation-item-actions" onclick="event.stopPropagation();">
                    <button onclick="deleteConversation('${id}', event)">åˆ é™¤</button>
                </div>
            `;
            
            listDiv.appendChild(item);
        });
    }
    
    // HTML è½¬ä¹‰å‡½æ•°
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // åˆ›å»ºæ–°å¯¹è¯
    window.createNewConversation = function() {
        currentConversationId = generateConversationId();
        conversationHistory = [];
        chatBox.innerHTML = '';
        renderConversationList();
        console.log('å·²åˆ›å»ºæ–°å¯¹è¯:', currentConversationId);
    };
    
    // æ–°å¯¹è¯å‡½æ•°ï¼ˆå…¼å®¹æ—§ä»£ç ï¼‰
    window.newChat = function() {
        createNewConversation();
    };
    
    // åŠ è½½æŒ‡å®šå¯¹è¯
    function loadConversation(id) {
        const conversations = loadConversations();
        const conv = conversations[id];
        
        if (!conv) {
            console.error('å¯¹è¯ä¸å­˜åœ¨:', id);
            return;
        }
        
        currentConversationId = id;
        conversationHistory = conv.messages || [];
        
        // æ¸²æŸ“å¯¹è¯å†å²
        chatBox.innerHTML = '';
        conversationHistory.forEach(msg => {
            if (msg.role === 'user' || msg.role === 'assistant') {
                appendMessage(msg.role, msg.content);
            }
        });
        
        chatBox.scrollTop = chatBox.scrollHeight;
        renderConversationList();
        console.log('å·²åŠ è½½å¯¹è¯:', id);
    }
    
    // åˆ é™¤å¯¹è¯
    window.deleteConversation = function(id, event) {
        event.stopPropagation();
        
        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå¯¹è¯å—ï¼Ÿ')) {
            return;
        }
        
        const conversations = loadConversations();
        delete conversations[id];
        saveConversations(conversations);
        
        // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰å¯¹è¯ï¼Œåˆ›å»ºæ–°å¯¹è¯
        if (id === currentConversationId) {
            createNewConversation();
        } else {
            renderConversationList();
        }
    };
    
    // ä¿å­˜å½“å‰å¯¹è¯
    function saveCurrentConversation() {
        if (!currentConversationId || conversationHistory.length === 0) {
            return;
        }
        
        const conversations = loadConversations();
        const existingConv = conversations[currentConversationId];
        
        // å¦‚æœå·²æœ‰æ ‡é¢˜ï¼Œä¿ç•™ï¼›å¦åˆ™ä»ç¬¬ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯ç”Ÿæˆ
        let title = existingConv?.title;
        if (!title || title === 'æ–°å¯¹è¯' || title.endsWith('...')) {
            const firstUserMessage = conversationHistory.find(m => m.role === 'user')?.content;
            if (firstUserMessage) {
                title = firstUserMessage.length > 20 ? firstUserMessage.substring(0, 20) + '...' : firstUserMessage;
            } else {
                title = 'æ–°å¯¹è¯';
            }
        }
        
        conversations[currentConversationId] = {
            id: currentConversationId,
            title: title,
            messages: [...conversationHistory],
            url: existingConv?.url || '', // ä¿ç•™å·²æœ‰çš„ URL
            createdAt: existingConv?.createdAt || Date.now(),
            updatedAt: Date.now()
        };
        
        saveConversations(conversations);
        renderConversationList();
    }
    
    // ç¼–è¾‘å¯¹è¯æ ‡é¢˜
    window.editConversationTitle = function(id, event) {
        event.stopPropagation();
        
        const conversations = loadConversations();
        const conv = conversations[id];
        if (!conv) return;
        
        const item = event.target.closest('.conversation-item');
        const titleDiv = item.querySelector('.conversation-item-title');
        const currentTitle = conv.title || 'æ–°å¯¹è¯';
        
        // åˆ›å»ºè¾“å…¥æ¡†
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'conversation-item-title-input';
        input.value = currentTitle.endsWith('...') ? currentTitle.substring(0, currentTitle.length - 3) : currentTitle;
        input.maxLength = 50;
        
        // æ›¿æ¢æ ‡é¢˜
        const oldTitle = titleDiv.textContent;
        titleDiv.style.display = 'none';
        titleDiv.parentNode.insertBefore(input, titleDiv);
        input.focus();
        input.select();
        
        // ä¿å­˜æ ‡é¢˜
        const saveTitle = () => {
            const newTitle = input.value.trim() || 'æ–°å¯¹è¯';
            const shortTitle = newTitle.length > 20 ? newTitle.substring(0, 20) + '...' : newTitle;
            
            conversations[id].title = shortTitle;
            saveConversations(conversations);
            
            titleDiv.textContent = shortTitle;
            titleDiv.style.display = '';
            input.remove();
            renderConversationList();
        };
        
        // å–æ¶ˆç¼–è¾‘
        const cancelEdit = () => {
            titleDiv.style.display = '';
            input.remove();
        };
        
        // ç»‘å®šäº‹ä»¶
        input.addEventListener('blur', saveTitle);
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveTitle();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                cancelEdit();
            }
        });
    };

    // åŠ è½½æä¾›è€…å’Œæ¨¡å‹åˆ—è¡¨
    async function loadProviders() {
        try {
            // ä½¿ç”¨è‡ªå®šä¹‰ API è·å–æä¾›è€…ä¿¡æ¯ï¼ˆç”¨äºæä¾›è€…é€‰æ‹©ï¼‰
            const providersRes = await fetch('http://localhost:24753/v1/providers');
            providersData = await providersRes.json();
            
            // ä½¿ç”¨ OpenAI SDK è·å–æ¨¡å‹åˆ—è¡¨ï¼ˆç¬¦åˆ OpenAI è§„èŒƒï¼‰
            const modelsResponse = await openai.models.list();
            modelsData = modelsResponse.data || [];
            
            // å¡«å……æä¾›è€…ä¸‹æ‹‰æ¡†
            providerSelect.innerHTML = '<option value="">é€‰æ‹©æä¾›è€…</option>';
            for (const [name, info] of Object.entries(providersData)) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = `${name} (${info.models.length} ä¸ªæ¨¡å‹)`;
                providerSelect.appendChild(option);
            }
            
            // é»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ªæä¾›è€…
            if (Object.keys(providersData).length > 0) {
                providerSelect.value = Object.keys(providersData)[0];
                onProviderChange();
            }
        } catch (err) {
            console.error('åŠ è½½æä¾›è€…å¤±è´¥:', err);
            providerSelect.innerHTML = '<option value="">åŠ è½½å¤±è´¥</option>';
            modelSelect.innerHTML = '<option value="">åŠ è½½å¤±è´¥</option>';
        }
    }

    // æä¾›è€…æ”¹å˜æ—¶æ›´æ–°æ¨¡å‹åˆ—è¡¨
    window.onProviderChange = function() {
        const selectedProvider = providerSelect.value;
        modelSelect.innerHTML = '<option value="">é€‰æ‹©æ¨¡å‹</option>';
        
        if (selectedProvider && providersData[selectedProvider]) {
            const models = providersData[selectedProvider].models;
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                option.textContent = model;
                modelSelect.appendChild(option);
            });
            
            // é»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ªæ¨¡å‹
            if (models.length > 0) {
                modelSelect.value = models[0];
            }
        }
    };

    // å°† send å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä»¥ä¾¿ HTML ä¸­çš„ onclick å¯ä»¥è°ƒç”¨
    window.send = async function() {
        const input = document.getElementById('prompt');
        const btn = document.getElementById('sendBtn');
        const newChatBtn = document.getElementById('newChatBtn');
        const text = input.value.trim();
        const selectedModel = modelSelect.value;
        
        if (!text) return;
        if (!selectedModel) {
            alert('è¯·å…ˆé€‰æ‹©æ¨¡å‹');
            return;
        }

        // åˆ¤æ–­æ˜¯å¦æ˜¯æ–°å¯¹è¯ï¼ˆå†å²ä¸ºç©ºï¼‰
        const isNewConversation = conversationHistory.length === 0;
        
        // å¦‚æœæ˜¯æ–°å¯¹è¯ï¼Œåˆ›å»ºæ–°çš„å¯¹è¯ID
        if (isNewConversation && !currentConversationId) {
            currentConversationId = generateConversationId();
        }

        // 1. ä¸Šå±ç”¨æˆ·æ¶ˆæ¯
        appendMessage('user', text);
        input.value = '';
        btn.disabled = true;
        newChatBtn.disabled = true;

        // 2. æ·»åŠ åˆ°å¯¹è¯å†å²
        conversationHistory.push({ role: "user", content: text });
        // ä¿å­˜å¯¹è¯åˆ°æœ¬åœ°å­˜å‚¨ï¼ˆç”¨æˆ·æ¶ˆæ¯ï¼‰
        saveCurrentConversation();

        // 3. åˆ›å»º AI æ¶ˆæ¯å ä½ç¬¦
        const aiMsgDiv = appendMessage('ai', 'æ­£åœ¨æ€è€ƒ...');
        let fullText = '';

        try {
            aiMsgDiv.innerText = ''; // æ¸…ç©º"æ­£åœ¨æ€è€ƒ..."

            // 4. æ„å»ºæ¶ˆæ¯åˆ—è¡¨ï¼ˆåŒ…å«å†å²æ¶ˆæ¯ï¼‰
            const messages = [...conversationHistory];

            console.log('å‘é€è¯·æ±‚:', {
                model: selectedModel,
                messagesCount: messages.length,
                newConversation: isNewConversation
            });

            // 5. è®¾ç½®å…¨å±€å˜é‡ï¼Œè®©è‡ªå®šä¹‰ fetch å¯ä»¥è®¿é—®
            window._currentNewConversation = isNewConversation;
            
            // 6. ä½¿ç”¨ OpenAI SDK å‘èµ·æµå¼è¯·æ±‚
            try {
                const stream = await openai.chat.completions.create({
                    model: selectedModel,
                    messages: messages,
                    stream: true
                });

                // 7. å¤„ç†æµå¼å“åº”ï¼ˆSDK è‡ªåŠ¨å¤„ç† SSE è§£æï¼‰
                // åˆ›å»ºæ€è€ƒå†…å®¹å®¹å™¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                let thinkingDiv = null;
                
                for await (const chunk of stream) {
                    const delta = chunk.choices[0]?.delta?.content;
                    if (delta) {
                        // æ£€æŸ¥æ˜¯å¦æ˜¯å¯¹è¯ URL
                        if (delta.startsWith('__URL__')) {
                            // å¯¹è¯ URLï¼šä¿å­˜åˆ°å½“å‰å¯¹è¯
                            const url = delta.substring('__URL__'.length);
                            if (currentConversationId && url) {
                                const conversations = loadConversations();
                                if (conversations[currentConversationId]) {
                                    conversations[currentConversationId].url = url;
                                    saveConversations(conversations);
                                    console.log('å·²ä¿å­˜å¯¹è¯ URL:', url);
                                }
                            }
                        }
                        // æ£€æŸ¥æ˜¯å¦æ˜¯æ€è€ƒå†…å®¹
                        else if (delta.startsWith('__THINKING__')) {
                            // æ€è€ƒå†…å®¹ï¼šç§»é™¤æ ‡è®°ï¼Œæ˜¾ç¤ºåœ¨æ€è€ƒåŒºåŸŸ
                            const thinkingContent = delta.substring('__THINKING__'.length);
                            
                            // åˆ›å»ºæˆ–è·å–æ€è€ƒå†…å®¹å®¹å™¨
                            if (!thinkingDiv) {
                                thinkingDiv = document.createElement('div');
                                thinkingDiv.className = 'thinking-content';
                                thinkingDiv.style.cssText = 'background: #f5f5f5; padding: 10px; margin: 10px 0; border-left: 3px solid #007bff; border-radius: 4px; font-style: italic; color: #666;';
                                thinkingDiv.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px; color: #007bff;">ğŸ’­ æ€è€ƒè¿‡ç¨‹ï¼š</div><div class="thinking-text"></div>';
                                aiMsgDiv.parentNode.insertBefore(thinkingDiv, aiMsgDiv);
                            }
                            
                            const thinkingTextDiv = thinkingDiv.querySelector('.thinking-text');
                            if (thinkingTextDiv) {
                                thinkingTextDiv.innerText += thinkingContent;
                            }
                            chatBox.scrollTop = chatBox.scrollHeight;
                        }
                        // æ£€æŸ¥æ˜¯å¦æ˜¯æ•´ä½“æ›¿æ¢æ¶ˆæ¯
                        else if (delta.startsWith('__REPLACE__')) {
                            // æ•´ä½“æ›¿æ¢ï¼šç§»é™¤æ ‡è®°ï¼Œæ›¿æ¢æ•´ä¸ªå†…å®¹
                            const replaceContent = delta.substring('__REPLACE__'.length);
                            fullText = replaceContent;
                            aiMsgDiv.innerText = fullText;
                            console.log('æ”¶åˆ°æ•´ä½“æ›¿æ¢æ¶ˆæ¯ï¼Œæ–°å†…å®¹é•¿åº¦:', fullText.length);
                            chatBox.scrollTop = chatBox.scrollHeight;
                        } else {
                            // å¢é‡æ›´æ–°ï¼šè¿½åŠ å†…å®¹
                            fullText += delta;
                            aiMsgDiv.innerText = fullText;
                            chatBox.scrollTop = chatBox.scrollHeight;
                        }
                    }
                }
            } catch (streamError) {
                // å¦‚æœæ˜¯ 400 é”™è¯¯ï¼Œå°è¯•è·å–è¯¦ç»†é”™è¯¯ä¿¡æ¯
                if (streamError.status === 400 || streamError.message?.includes('400')) {
                    console.error('400 é”™è¯¯è¯¦æƒ…:', streamError);
                    // å°è¯•ä»é”™è¯¯å¯¹è±¡ä¸­è·å–æ›´å¤šä¿¡æ¯
                    if (streamError.error) {
                        console.error('é”™è¯¯è¯¦æƒ…:', streamError.error);
                        throw new Error(`è¯·æ±‚é”™è¯¯: ${JSON.stringify(streamError.error)}`);
                    }
                }
                throw streamError;
            } finally {
                // æ¸…ç†å…¨å±€å˜é‡
                delete window._currentNewConversation;
            }

            // 7. å°† AI å›å¤æ·»åŠ åˆ°å¯¹è¯å†å²
            if (fullText) {
                conversationHistory.push({ role: "assistant", content: fullText });
                // ä¿å­˜å¯¹è¯åˆ°æœ¬åœ°å­˜å‚¨
                saveCurrentConversation();
            }

        } catch (err) {
            aiMsgDiv.innerText = 'é”™è¯¯: ' + err.message;
            console.error('è¯·æ±‚é”™è¯¯:', err);
            // å¦‚æœå‡ºé”™ï¼Œä»å†å²ä¸­ç§»é™¤åˆšæ‰æ·»åŠ çš„ç”¨æˆ·æ¶ˆæ¯
            conversationHistory.pop();
        } finally {
            // æ¸…ç†å…¨å±€å˜é‡
            delete window._currentNewConversation;
            btn.disabled = false;
            newChatBtn.disabled = false;
        }
    };

    function appendMessage(role, text) {
        const div = document.createElement('div');
        div.className = `message ${role}`;
        div.innerText = text;
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
        return div;
    }

    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
    // ç”±äºæ˜¯ ES6 æ¨¡å—ï¼Œä»£ç æ‰§è¡Œæ—¶ DOM å¯èƒ½å·²ç»åŠ è½½å®Œæˆ
    // æ‰€ä»¥åŒæ—¶æ£€æŸ¥ DOMContentLoaded å’Œç›´æ¥æ‰§è¡Œ
    function initializePage() {
        // åŠ è½½å¯¹è¯åˆ—è¡¨
        renderConversationList();
        // å¦‚æœæœ‰å¯¹è¯ï¼ŒåŠ è½½æœ€æ–°çš„ä¸€ä¸ª
        const conversations = loadConversations();
        const sortedConvs = Object.entries(conversations).sort((a, b) => 
            b[1].updatedAt - a[1].updatedAt
        );
        if (sortedConvs.length > 0) {
            loadConversation(sortedConvs[0][0]);
        } else {
            // æ²¡æœ‰å†å²å¯¹è¯ï¼Œåˆ›å»ºæ–°å¯¹è¯
            createNewConversation();
        }
    }
    
    // å¦‚æœ DOM å·²ç»åŠ è½½å®Œæˆï¼Œç›´æ¥æ‰§è¡Œï¼›å¦åˆ™ç­‰å¾… DOMContentLoaded
    if (document.readyState === 'loading') {
        window.addEventListener('DOMContentLoaded', initializePage);
    } else {
        // DOM å·²ç»åŠ è½½å®Œæˆï¼Œç›´æ¥æ‰§è¡Œ
        initializePage();
    }
    
    // é¡µé¢åŠ è½½æ—¶è·å–æä¾›è€…å’Œæ¨¡å‹åˆ—è¡¨
    loadProviders();
</script>
</body>
</html>